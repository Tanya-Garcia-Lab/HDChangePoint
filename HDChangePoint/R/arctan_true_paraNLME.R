######################################################################################
# Main function to generate simulation results for the parametric NLME approach.    ##
# True data are generated by the arctangent model                                   ##
# the parametric NLME estimation is performed under the artangent model  (correct)  ##
######################################################################################

#' Title
#'
#' @param n
#' @param model
#' @param dat
#' @param num.boot
#' @param num.interp
#' @param true.gam1
#' @param true.gam3
#' @param para1
#' @param para2
#' @param para3
#' @param para4
#' @param para5
#' @param eps.sd
#' @param dist
#'
#' @return Generate simulation results for the parametric NLME approach, where true data are generated by the arctangent model
#'         and the parametric NLME estimation is performed under the correct (arctangent) model.
#' @export
#'
#' @examples #library(nlme); library(scam);  library(ShapeChange);
#'
#'             library(registry); library(pkgmaker); library(rngtools); library(iterators);
#'             library(foreach); library(parallel);
#'
#'             libaray(doParallel); nworkers<-detectCores()
#'             cl<-makePSOCKcluster(nworkers);
#'             library(doMC); registerDoMC(nworkers)
#'             library(doRNG)
#'
#'             set.seed(1)
#'             outdat<-mydata(n=80, model="arctan", p=2, bb0=2, bb=0.1, x.sd=0.3, v1=5, v2=7, dist="normal", eps.sd=0.05, u.sd=0.05)
#'
#'             #parallel computing
#'             results<-foreach(i=1:nsim)%dorng%{
#'
#'                                 main.arctan.nlme(n=80, model="arctan", dat=outdat, num.boot=1000,   num.interp=45, true.gam1=2.45/pi, true.gam3=pi/1.1, para1=0.8,
#'                                              para2=6.1, para3=0, para4=2.8, para5=1.5,  eps.sd=0.05, dist="normal")
#'                                 }
#'             stopCluster(cl)
#'
main.arctan.nlme<-function(n=80, model="arctan", dat=outdat, num.boot=1000,   num.interp=45, true.gam1=2.45/pi, true.gam3=pi/1.1, para1=0.8,  para2=0.2, para3=0.2, para4=2.8, para5=1.5,  eps.sd=0.05, dist="normal"){


  ################################################################
  ## data structure constructed by each subject:  List format  ###
  ## include subject i, covariate log age,                     ###
  ##         true nonlinear function omega, error term         ###
  ##         true inflection points, true beta,                ###
  ##         true covariate W associated with inflection pts   ###
  ################################################################



  tms.dat<-vector("list", n)


  for(id in 1:n){

    sub.dat<-dat[dat$subj.id==id, ]
    ll<-dim(sub.dat)[1]

    subj<-sub.dat$subj.id
    true.z<-sub.dat$true_z
    W.cov<-sub.dat$cov.W
    gender<-sub.dat$sex

    if (dist=="normal"){
      eps<-rnorm(ll,0,eps.sd)
    }


    logS<-sub.dat$xx
    tr.z<-unique(sub.dat$true_z)

    #omega<-w(logS, tr.z, model)
    omega<-sub.dat$omega
    tms<-omega+eps

    tms.dat[[id]]<-cbind(subj,tms, omega, logS, W.cov, gender, eps, true.z)  # true.t,


  }


  ## create data.frame from list type of data
  gendat<-do.call("rbind.data.frame", tms.dat)

  ## Create grouped Data
  newgrdata<-groupedData(tms~logS|subj, data=gendat, order.groups=FALSE)


  #################################################################################################################################################
  ## Fit nonlinear mixed model using nlme() in NLME package to estimate fixed effects and random effects
  ## in longitudinal model: true data are generated by logistic model
  ## tms: longitudinal response vector for a subject i and jth visit.
  ## logistf: fitted nonlinear model.
  ## theta1: fixed effect
  ## theta2: log transformed inflection points, which is modeled by linear relationship with
  ##         subject specific covariate W.cov, containig fixed effect beta and random effects u
  ##
  ## logS: main covariate in the logitudinal model
  ## model: tms ~logistf(theta1, theta2,  logS)
  ## fixed: two sided linear model in the form of f1~x1, where f1: names of parameters, x1: covariates in the ##linear relationship with f1
  ##       eg. theat1 ~1
  ## random: two sided formula in the form of r1~x1, where r1: names of parameters, x1 specifies the random effects model for the parameter r1
  ## groups: ~g1 or ~g1/g2../gQ, specify the partitions of the data over which the random effects vary
  ## start: list of initial estimates for the fixed effects and random effects
  ## method: "REML" or "ML", modle is fit by maximizing the restricted log liklihood or log-likelihood.
  ## verbose: TRUE means information on the evoluation of the interative algorithm is printed. Default is FALSE.
  ###################################################################################################################################################


  tms.nlme<-nlme(tms~arctanf(gam1, gam2, gam3, gam4,  logS), fixed=list(gam1~1, gam2~1+W.cov, gam3~1, gam4~1),
                 random=gam2~1|subj,
                 data=newgrdata, groups=~subj, start=list(fixed=c(para1,para2,para3,para4,para5)), method="ML", verbose=FALSE)


  #############################################
  ### logLike, AIC #
  #############################################
  tms.logLik<-summary(tms.nlme)$logLik
  tms.AIC<-summary(tms.nlme)$AIC

  #############################################
  ### estimates of fixed effect: theta1, beta #
  #############################################

  est.gam1<-summary(tms.nlme)$tTable[,"Value"]["gam1"]
  est.gam3<-summary(tms.nlme)$tTable[,"Value"]["gam3"]
  est.gam4<-summary(tms.nlme)$tTable[,"Value"]["gam4"]
  est.beta<-summary(tms.nlme)$tTable[,"Value"]["gam2.W.cov"]
  est.beta0<-summary(tms.nlme)$tTable[,"Value"]["gam2.(Intercept)"]

  #####################################
  ## standard errors of fixed effects #
  #####################################


  est.str.gam1<-summary(tms.nlme)$tTable[,"Std.Error"]["gam1"]
  est.str.gam3<-summary(tms.nlme)$tTable[,"Std.Error"]["gam3"]
  est.str.gam4<-summary(tms.nlme)$tTable[,"Std.Error"]["gam4"]
  est.str.beta<-summary(tms.nlme)$tTable[,"Std.Error"]["gam2.W.cov"]
  est.str.beta0<-summary(tms.nlme)$tTable[,"Std.Error"]["gam2.(Intercept)"]


  ##########################
  ##  coverage probability #
  ##########################
  cp.fixed<-intervals(tms.nlme, level=0.95, which=c("fixed"))

  ###########################################
  ##  coverage probability for fixed effects#
  ###########################################
  cp.lower.gam1<- cp.fixed$fixed["gam1","lower"]
  cp.upper.gam1<- cp.fixed$fixed["gam1","upper"]

  ###########################################
  ##  coverage probability for fixed effects#
  ###########################################
  cp.lower.beta0<- cp.fixed$fixed["gam2.(Intercept)","lower"]
  cp.upper.beta0<- cp.fixed$fixed["gam2.(Intercept)","upper"]

  ###########################################
  ##  coverage probability for fixed effects#
  ###########################################
  cp.lower.beta<- cp.fixed$fixed["gam2.W.cov","lower"]
  cp.upper.beta<- cp.fixed$fixed["gam2.W.cov","upper"]

  ###########################################
  ##  coverage probability for fixed effects#
  ###########################################
  cp.lower.gam3<-cp.fixed$fixed["gam3","lower"]
  cp.upper.gam3<-cp.fixed$fixed["gam3","upper"]


  ###########################################
  ##  coverage probability for fixed effects#
  ###########################################
  cp.lower.gam4<-cp.fixed$fixed["gam4","lower"]
  cp.upper.gam4<-cp.fixed$fixed["gam4","upper"]


  #####################
  ##  scale parameter #
  #####################

  ## within-individual ##
  sig.eps<-tms.nlme$sigma



  ##########################################################################
  #an approximate covariance matrix for the variance-covariance coefficients
  ##########################################################################
  ## standard errors ##
  str.sigma.u<-sqrt(summary(tms.nlme)$apVar["reStruct.subj","reStruct.subj"])
  str.sigma.eps<-sqrt(summary(tms.nlme)$apVar["lSigma","lSigma"])


  ##########################
  ##  coverage probability #
  ##########################
  cp.varcov<-intervals(tms.nlme, level=0.95, which=c("var-cov"))


  #########################################################
  ##  coverage probability for Within-group standard error#
  #########################################################
  #names(cp.varcov): sigma :	within-group standard deviation

  cp_sigma_eps_lower<- as.numeric(cp.varcov$sigma["lower"])
  cp_sigma_eps_upper<-as.numeric(cp.varcov$sigma["upper"])


  #######################################################################
  ## estimated variance or standard deviations in random effects term ###
  #######################################################################
  sig.u<-as.numeric(VarCorr(tms.nlme)["gam2.(Intercept)","StdDev"])

  ################################################
  ##  coverage probability for sd(Random Effects)#
  ################################################

  cp_sigma_u_lower<- as.numeric(cp.varcov$reStruct$subj["sd(gam2.(Intercept))","lower"])
  cp_sigma_u_upper<-as.numeric(cp.varcov$reStruct$subj["sd(gam2.(Intercept))","upper"])




  ###############################################################
  ## Extract Random effects with augmented data from groupedData#
  ###############################################################
  augmented.dat<-random.effects(tms.nlme, augFrame=T, data=newgrdata);
  est.rand.ef<-augmented.dat[,"gam2.(Intercept)"];



  ##################################################
  ## estimate inflection points (random effects)  ##
  ## estimate bias for inflection points          ##
  ##################################################

  est.logT<-est.beta0+est.beta*augmented.dat[,"W.cov"]+est.rand.ef  # estimated logT
  true.logT<-augmented.dat[,"true.z"]




  #####################################################################################################
  ### predict(): popoulation prediction (random effects=0) at polulation level 0                    ###
  ###              within group predictions (use estimated random effects) at individual level 1    ###
  #####################################################################################################


  #########################################
  # predicted total motor score           #
  #########################################

  ## set the length of time points
  if ((num.interp %% 2)==0){
    org.time.length<-num.interp/2
  }else{
    org.time.length<-ceiling(num.interp/2)
  }


  new.pred.data<- array(0, dim=c(org.time.length, 5, n),
                        dimnames=list(paste("visit",1:org.time.length,sep=""), c("pseudo.id","pseudo.logS","pseudo.wcov", "ture.pseudo.tms", "est.pseudo.tms"), paste("ID",1:n,sep="")));


  for (id in 1:n){

    #id<-1; rm(id)
    group<-newgrdata[newgrdata$subj==id, ]


    pseudo.xy<-approx(group[,"logS"], group[,"omega"], n=org.time.length)
    pseudo.logS<-pseudo.xy$x
    pseudo.omega<-pseudo.xy$y

    pseudo.id<-rep(id, org.time.length)
    pseudo.wcov<-rep(unique(group[,"W.cov"]), org.time.length)

    if (dist=="normal"){
      pseudo.err<-rnorm(org.time.length,0, eps.sd)

    }

    pseudo.tms<-pseudo.omega+pseudo.err

    new.dat<-cbind(pseudo.id, pseudo.logS, pseudo.wcov,  pseudo.tms)


    pred.data<-data.frame(subj= new.dat[,"pseudo.id"], logS= new.dat[,"pseudo.logS"],
                          W.cov=new.dat[ ,"pseudo.wcov"])

    ## predictions for tms  based on newd
    pred.traj<-predict(tms.nlme, pred.data, level=1)
    new.pred.data[,,id]<-cbind(pseudo.id, pseudo.logS, pseudo.wcov,  pseudo.tms, pred.traj)

  }


  boot.est.logT<-array(0, dim=c(n, num.boot),
                       dimnames=list(paste("id",1:n,sep=""),paste("boot",1:num.boot,sep=""))
  )

  for(b in 1:num.boot){


    boot.pred.data<-vector("list", n)



    for(id in 1:n){

      ind.pred.data<-new.pred.data[,,id]
      boot.size<-dim(ind.pred.data)[[1]]
      err<-ind.pred.data[, "ture.pseudo.tms"]-ind.pred.data[, "est.pseudo.tms"]
      err.boot<-sample(err, size=boot.size, replace=TRUE)
      boot.tms<-ind.pred.data[, "est.pseudo.tms"]+err.boot
      boot.pred.data[[id]]<-cbind(ind.pred.data, boot.tms)

    }

    boot.data<-do.call("rbind.data.frame", boot.pred.data)



    boot.tms.nlme<-nlme(boot.tms~arctanf(gam1, gam2, gam3, gam4, pseudo.logS), fixed=list(gam1~1, gam2~1+pseudo.wcov, gam3~1, gam4~1),
                        random=gam2~1|pseudo.id,
                        data=boot.data, groups=~pseudo.id, start=list(fixed=c(para1,para2,para3,para4,para5)), method="ML", verbose=FALSE)

    boot.est.beta<-summary(boot.tms.nlme)$tTable[,"Value"]["gam2.pseudo.wcov"]
    boot.est.beta0<-summary(boot.tms.nlme)$tTable[,"Value"]["gam2.(Intercept)"]


    boot.augmented.dat<-random.effects(boot.tms.nlme, augFrame=T, data=boot.data)
    boot.est.rand.ef<-boot.augmented.dat[,"gam2.(Intercept)"]

    boot.est.logT[,b]<-boot.est.beta0+boot.est.beta*boot.augmented.dat[,"pseudo.wcov"]+boot.est.rand.ef  # estimated logT

  }



  ind.sd<-rep(100,n);
  cp.boot<-array(0, dim=c(n, 2),
                 dimnames=list(paste("id",1:n,sep=""),c("95% lower", "95% upper"))
  )


  for (id in 1:n){
    ind.boot<-boot.est.logT[id, ]
    ind.sd[id]<-sd(ind.boot)
    order.ind.boot<-sort(ind.boot)
    cp.boot[id,]<-quantile(order.ind.boot, prob=c(0.025, 0.975))

  }


  #plot(boot.pred.data[[1]][,"logS"], boot.pred.data[[1]][,"boot.tms"], )

  #########################################################
  # First and Second Derivative of Longitudinal Responses #
  #########################################################


  true.first.deriv<-array(0, dim=c(org.time.length,n),
                          dimnames=list(paste("visit",1:org.time.length,sep=""),paste("ID",1:n,sep="")))
  true.second.deriv<-array(0, dim=c(org.time.length,n),
                           dimnames=list(paste("visit",1:org.time.length,sep=""),paste("ID",1:n,sep="")))

  est.first.deriv<-array(0, dim=c(org.time.length,n),
                         dimnames=list(paste("visit",1:org.time.length,sep=""),paste("ID",1:n,sep="")))
  est.second.deriv<-array(0, dim=c(org.time.length,n),
                          dimnames=list(paste("visit",1:org.time.length,sep=""),paste("ID",1:n,sep="")))


  for (id in 1:n){
    sub.logs<-new.pred.data[,"pseudo.logS",id]


    true.first.deriv[,id]<-arctan_first_deriv_ft(true.gam1, true.logT[id], true.gam3,  sub.logs)
    true.second.deriv[,id]<-arctan_second_deriv_ft(true.gam1,  true.logT[id], true.gam3,  sub.logs)


    est.first.deriv[,id]<-arctan_first_deriv_ft(est.gam1,  est.logT[id], est.gam3,  sub.logs)
    est.second.deriv[,id]<-arctan_second_deriv_ft(est.gam1,  est.logT[id], est.gam3,  sub.logs)


  }





  return(list(  new.pred.data=new.pred.data, est.gam1=est.gam1, est.gam3=est.gam3,est.gam4=est.gam4, est.beta=est.beta, est.beta0=est.beta0, #estimates

                est.str.gam1=est.str.gam1, est.str.gam3=est.str.gam3, est.str.gam4=est.str.gam4, est.str.beta=est.str.beta,est.str.beta0=est.str.beta0,#standard errors

                cp.lower.gam1=cp.lower.gam1, cp.upper.gam1=cp.upper.gam1, cp.lower.gam3=cp.lower.gam3, cp.upper.gam3=cp.upper.gam3,
                cp.lower.gam4=cp.lower.gam4, cp.upper.gam4=cp.upper.gam4,
                cp.lower.beta0=cp.lower.beta0, cp.upper.beta0=cp.upper.beta0, cp.lower.beta=cp.lower.beta, cp.upper.beta=cp.upper.beta, #coverage prob


                newgrdata=newgrdata, sig.eps=sig.eps, cp_sigma_eps_lower=cp_sigma_eps_lower, cp_sigma_eps_upper=cp_sigma_eps_upper,
                str.sigma.eps=str.sigma.eps,
                sig.u=sig.u,   cp_sigma_u_lower=cp_sigma_u_lower, cp_sigma_u_upper=cp_sigma_u_upper,
                str.sigma.u=str.sigma.u,


                est.rand.ef=est.rand.ef,
                est.logT=est.logT, true.logT=true.logT, true.first.deriv=true.first.deriv,  true.second.deriv= true.second.deriv,  est.first.deriv= est.first.deriv, est.second.deriv=est.second.deriv,
                boot.est.logT=boot.est.logT,  ind.sd=ind.sd, cp.boot=cp.boot
  ))

}



#################################################################
# summary function for the parametric NLME                  #####
# where true data are generated by arctangent Model         #####
#################################################################


#' Title
#'
#' @param nsim
#' @param n
#' @param res
#' @param num.interp
#' @param true.gam1
#' @param true.gam3
#' @param true.gam4
#' @param beta
#' @param beta0
#' @param file
#'
#' @return summarize simulation results from the parametric NLME estimation, where the true data is generated by the
#'         arctangent model and the estimation is performed under the artangent model.
#' @export
#'
#' @examples  simus.arctan.out<-arctan.results(nsim=100, n=80, res=results, num.interp=45, true.gam1=(2.45/pi), true.gam3=(pi/1.1), true.gam4=0.8,  beta=0.1, beta0=2,  file="nlme_arctan_")
#'
#'
#'
arctan.results<-function(nsim=100, n=80, res=results, num.interp=45, true.gam1=(2.45/pi), true.gam3=(pi/1.1), true.gam4=0.8,  beta=0.1, beta0=2,  file="nlme_arctan_"){


  #true.eps=0.05, true.u=0.05,
  #############################################
  ### Fixed effects                       #####
  ###    #theta1                          #####
  ###    #theta2 =beta*W_cov+ranom.effect #####
  #############################################

  ############
  ## estimates
  ############

  ## main fixed effects
  estimated.gam1<-do.call("rbind",lapply(res,function(x) x$est.gam1))
  estimated.gam3<-do.call("rbind",lapply(res,function(x) x$est.gam3))
  estimated.gam4<-do.call("rbind",lapply(res,function(x) x$est.gam4))

  ## baseline effects
  estimated.beta<-do.call("rbind",lapply(res,function(x) x$est.beta))
  estimated.beta0<-do.call("rbind",lapply(res,function(x) x$est.beta0))


  ## average of fixed effects
  mean.est.fixed.eff<-apply(cbind(estimated.gam1, estimated.gam3,estimated.gam4,estimated.beta, estimated.beta0),2, mean)

  ## standard deviation of fixed effects
  sd.est.fixed.eff<-apply(cbind(estimated.gam1, estimated.gam3,  estimated.gam4, estimated.beta, estimated.beta0),2, sd)

  ##
  true.fixed.eff<-c(true.gam1,true.gam3, true.gam4, beta, beta0)


  ####################################
  ### bias of fixed estimates
  ####################################
  abs.bias.fixed.eff<-abs(mean.est.fixed.eff-true.fixed.eff)


  #############################################
  ## standard errors of fixed effects
  #############################################
  estimated.str.gam1<-do.call("rbind",lapply(res,function(x) x$est.str.gam1))
  estimated.str.gam3<-do.call("rbind",lapply(res,function(x) x$est.str.gam3))
  estimated.str.gam4<-do.call("rbind",lapply(res,function(x) x$est.str.gam4))

  estimated.str.beta0<-do.call("rbind",lapply(res,function(x) x$est.str.beta0))
  estimated.str.beta<-do.call("rbind",lapply(res,function(x) x$est.str.beta))


  est.avr.str.gam1<-mean(estimated.str.gam1)
  est.avr.str.gam3<-mean(estimated.str.gam3)
  est.avr.str.gam4<-mean(estimated.str.gam4)
  est.avr.str.beta0<-mean(estimated.str.beta0)
  est.avr.str.beta<-mean(estimated.str.beta)

  ########################################
  ## coverage probabilities for theta1
  ########################################
  estimated.lowercp.gam1<-do.call("rbind",lapply(res,function(x) x$cp.lower.gam1))
  estimated.uppercp.gam1<-do.call("rbind",lapply(res,function(x) x$cp.upper.gam1))
  #apply(cbind(estimated.lowercp.theta1,estimated.uppercp.theta1),2,mean)

  #UBtheta1<-estimated.theta1+1.96*estimated.str.theta1
  #LBtheta1<-estimated.theta1-1.96*estimated.str.theta1


  ind1gam1<- do.call("rbind",lapply(estimated.uppercp.gam1,function(x) 1*(x-(true.gam1)>0)))
  ind2gam1<- do.call("rbind",lapply(estimated.lowercp.gam1,function(x) 1*(x-(true.gam1)<0)))
  indgam1<-ind1gam1*ind2gam1

  cpgam1<-mean(indgam1)

  ########################################
  ## coverage probabilities for theta3 ###
  ########################################
  estimated.lowercp.gam3<-do.call("rbind",lapply(res,function(x) x$cp.lower.gam3))
  estimated.uppercp.gam3<-do.call("rbind",lapply(res,function(x) x$cp.upper.gam3))

  ind1gam3<- do.call("rbind",lapply(estimated.uppercp.gam3,function(x) 1*(x-(true.gam3)>0)))
  ind2gam3<- do.call("rbind",lapply(estimated.lowercp.gam3,function(x) 1*(x-(true.gam3)<0)))
  indgam3<-ind1gam3*ind2gam3

  cpgam3<-mean(indgam3)

  ########################################
  ## coverage probabilities for theta3 ###
  ########################################
  estimated.lowercp.gam4<-do.call("rbind",lapply(res,function(x) x$cp.lower.gam4))
  estimated.uppercp.gam4<-do.call("rbind",lapply(res,function(x) x$cp.upper.gam4))


  ind1gam4<- do.call("rbind",lapply(estimated.uppercp.gam4,function(x) 1*(x-(true.gam4)>0)))
  ind2gam4<- do.call("rbind",lapply(estimated.lowercp.gam4,function(x) 1*(x-(true.gam4)<0)))
  indgam4<-ind1gam4*ind2gam4

  cpgam4<-mean(indgam4)


  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta0))
  estimated.uppercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta0))

  ind1b0<- do.call("rbind",lapply(estimated.uppercp.beta0,function(x) 1*(x-(beta0)>0)))
  ind2b0<- do.call("rbind",lapply(estimated.lowercp.beta0,function(x) 1*(x-(beta0)<0)))
  indb0<-ind1b0*ind2b0

  cpb0<-mean(indb0)



  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta))
  estimated.uppercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta))

  ind1b<- do.call("rbind",lapply(estimated.uppercp.beta,function(x) 1*(x-(beta)>0)))
  ind2b<- do.call("rbind",lapply(estimated.lowercp.beta,function(x) 1*(x-(beta)<0)))
  indb<-ind1b*ind2b

  cpb<-mean(indb)



  ######################
  ### summarization ####
  ######################

  ## theta1
  estimates.gam1<-data.frame(mean.est.fixed.eff["gam1"],  abs.bias.fixed.eff["gam1"], sd.est.fixed.eff["gam1"],est.avr.str.gam1, cpgam1)
  colnames(estimates.gam1)<-c("est", "abs.bias", "sd", "str", "cp")

  ## theta3
  estimates.gam3<-data.frame(mean.est.fixed.eff["gam3"],  abs.bias.fixed.eff["gam3"], sd.est.fixed.eff["gam3"],est.avr.str.gam3, cpgam3)
  colnames(estimates.gam3)<-c("est", "abs.bias", "sd", "str", "cp")

  ## theta4
  estimates.gam4<-data.frame(mean.est.fixed.eff["gam4"],  abs.bias.fixed.eff["gam4"], sd.est.fixed.eff["gam4"],est.avr.str.gam4, cpgam4)
  colnames(estimates.gam4)<-c("est", "abs.bias", "sd", "str", "cp")


  ## beta0 #mean.est.fixed.eff["gam2.(Intercept)"],"est",
  estimates.beta0<-data.frame(  abs.bias.fixed.eff["gam2.(Intercept)"], sd.est.fixed.eff["gam2.(Intercept)"],  est.avr.str.beta0,  cpb0)
  colnames(estimates.beta0)<-c("abs.bias", "sd", "str", "cp")


  ## beta #mean.est.fixed.eff["gam2.W.cov"],"est",
  estimates.beta<-data.frame(  abs.bias.fixed.eff["gam2.W.cov"], sd.est.fixed.eff["gam2.W.cov"],  est.avr.str.beta,  cpb)
  colnames(estimates.beta)<-c( "abs.bias", "sd", "str", "cp")

  #fixed.est<-rbind(estimates.gam1,estimates.gam3, estimates.gam4, estimates.beta0, estimates.beta)
  #rownames(fixed.est)<-c("gam1", "gam3","gam4", "beta0", "beta")

  fixed.est<-rbind(estimates.beta0, estimates.beta)
  rownames(fixed.est)<-c( "beta0", "beta")
  fixed.est<-round(fixed.est, 3)


  #############################################
  ### Random effect where                   ###
  ###    #theta2 =beta*W_cov+ranom.effect   ###
  #############################################

  ## random effect for Each ID (columwise) based on 100 simulation
  estimated.random.eff<-do.call("rbind",lapply(res,function(x) x$est.rand.ef))
  avr.est.random.eff<-apply(estimated.random.eff,2, mean)


  #######################################################
  ## Inflection Point                               #####
  ## est.logT is the same as fixed effect theta2    #####
  ## est.logT=\hat(beta)*W_cov+\hat(ranom.effect)   #####
  #######################################################

  ###############
  # True logT  ##
  ###############

  TRUE.logT<-do.call("rbind",lapply(res,function(x) x$true.logT))
  tr.logT<-apply(TRUE.logT,2, mean)


  #############
  # Estimates #
  #############

  estimated.logT<-do.call("rbind",lapply(res,function(x) x$est.logT))
  ind.abs.bias<-abs(estimated.logT-TRUE.logT) ## individual biases for each subject
  avr.ind.abs.bias<-apply(ind.abs.bias, 1, mean) ## average ind.abs.bias across subjects


  ##############
  ## bias logT #
  ##############
  avr.sim.ind.abs.bias<-mean(avr.ind.abs.bias)

  ##############
  ## sd logT #
  ##############
  #avr.est.logT<-apply(estimated.logT,2, mean)
  sd.est.logT<-apply(estimated.logT,2, sd) # sd of logT over simulation runs
  avr.sd.est.logT<-mean(sd.est.logT)       # avr of sd of logT across subjects

  #bias.logT<-abs(avr.est.logT-tr.logT)   ## mean(bias.logT)

  ## bootstrap str
  #boot.est.logT=boot.est.logT,  ind.sd=ind.sd, cp.boot=cp.boot
  boot.ind.sd<-do.call("rbind",lapply(res,function(x) x$ind.sd))
  avr.boot.ind.sd<-apply(boot.ind.sd,2, mean) # average of bootstrap sd over simulation runs
  avr.boot.str<-mean(avr.boot.ind.sd) # average of bootstrap sd across subjects



  # sd(results[[1]]$boot.est.logT[1,])
  boot.est.cp<-do.call("rbind",lapply(res,function(x) x$cp.boot))
  boot.ind.cp<-array(0, dim=c(n, 2, nsim), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))
                                                         ,paste("sim",1:nsim,sep="")))

  for(s in 1:nsim){
    # s<-1
    boot.ind.cp[,, s]<-boot.est.cp[(1+(s-1)*80):(s*80),]
  }

  avr.boot.ind.cp<-array(0, dim=c(n, 2), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))))

  for (id in 1:n){
    avr.boot.ind.cp[id,]<-apply(boot.ind.cp[id,,1:nsim],1,mean)
  }



  ###################################
  ## average of inflection points ###
  ###################################
  avr.est.logT<-apply(estimated.logT, 2, mean)
  glob.logT<-mean(avr.est.logT)


  #################################
  ### global logT summarization ###
  #################################

  glob.logT.est<-cbind(avr.sim.ind.abs.bias,  avr.sd.est.logT, avr.boot.str)
  colnames(glob.logT.est)<-c("Bias", "ESD", "ASE")
  rownames(glob.logT.est)<-c("est")
  glob.logT.est<-round(glob.logT.est, 3)

  ind.logT.cp<-cbind(avr.est.logT, avr.boot.ind.cp)
  glob.logT.cp<-apply(ind.logT.cp, 2, mean)


  ######################################
  ###### plot for estimated omega ######
  ######################################

  newl<-ceiling(num.interp/2)



  true.tms<-array(0, dim=c(nsim, newl, n),
                  dimnames = list(paste("sim",1:nsim,sep=""),paste("visit",1:newl,sep=""), paste("id",1:id,sep="")
                  ))
  subj.logS<-true.tms
  est.tms<-true.tms

  ind.avr.true.tms<-array(0, dim=c(newl, n),
                          dimnames = list(paste("visit",1:newl,sep=""), paste("id",1:id,sep="")
                          ))

  ind.avr.true.xx<-ind.avr.true.tms
  ind.avr.est.tms<-ind.avr.true.tms

  for (id in 1:n){
    for (sim in 1:nsim){

      true.tms[sim,,id]<-res[[sim]]$new.pred.data[, "ture.pseudo.tms", id]
      est.tms[sim,,id]<-res[[sim]]$new.pred.data[, "est.pseudo.tms", id]
      subj.logS[sim,,id]<-res[[sim]]$new.pred.data[, "pseudo.logS", id]
    }
    ind.avr.true.tms[, id]<- apply(true.tms[,, id], 2, mean)
    ind.avr.est.tms[, id]<- apply(est.tms[,, id], 2, mean)
    ind.avr.true.xx[, id]<- apply(subj.logS[,, id], 2, mean)
  }


  mean.true.tms<-apply(ind.avr.true.tms,1,mean)
  mean.est.tms<-apply(ind.avr.est.tms,1,mean)
  mean.true.xx<-apply(ind.avr.true.xx,1,mean)




  ################################################
  # Plot of Average of Longitudinal trajectories #
  ################################################

  postscript(paste(file,"average_longitudinal_trajectory.eps",sep=""))
  #pdf(file="arctan_true.pdf")

  par(mar=c(6.1,5.1,2.5,1.1))

  ## Create a blank plot
  ymin<-min(mean.true.tms)-0.1
  ymax<-max(mean.true.tms)+0.5
  xmin<-min(mean.true.xx)-0.3
  xmax<-max(mean.true.xx)+0.3

  #average of trajectories of all subjects
  plot( mean.true.xx,      mean.true.tms,  ylim=c(ymin,  ymax), xlim=c(xmin, xmax), xlab="x", ylab=expression("paraNLME"(omega(x))),
        cex.lab=1.3, cex.axis=1.0,
        main="Average of Individual Trajectories",  font=1.2,
        col="black", lty=1, lwd=2, type="l") # sub='(a)', cex.sub=1.3,

  lines( mean.true.xx,  mean.true.tms, col="red", lty=2, lwd=2)

  segments(glob.logT, 0, glob.logT,median(mean.est.tms)+0.5,  col="blue", lty=3, lwd=2)

  legend( xmin, ymax, c("True Trajectory", "Estimated Trajectory"), col=c("black", "red"),
         lty=c(1,2),bty="n",cex=1.3,lwd=rep(2,2))
  mtext('(e)', outer=F,side=1,line=4.5, cex=1.3)

  dev.off()



  ###########################################
  ## First and Second Derivative Estimation #
  ###########################################


  ### True First Derivative : all simulations are the same at true values
  true.first.deriv<-apply(res[[1]]$true.first.deriv,1,mean)
  true.second.deriv<-apply(res[[1]]$true.second.deriv,1,mean)


  ## predicted values for omega at the population and subject levels

  subj.first.deriv<-array(0, dim=c(nsim, newl,n),
                          dimnames = list(paste("nsim",1:nsim,sep=""),paste("visit",1:newl,sep="")
                                          ,paste("ID",1:n,sep="")))

  subj.second.deriv<-subj.first.deriv
  mean.subj.first.deriv<-array(0, dim=c(newl,n),
                               dimnames = list(paste("visit",1:newl,sep="")
                                               ,paste("ID",1:n,sep="")))

  mean.subj.second.deriv<-mean.subj.first.deriv


  for (id in 1:n){

    subj.first.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.first.deriv[,id]))
    mean.subj.first.deriv[,id]<-apply(subj.first.deriv[,,id],2,mean)

    subj.second.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.second.deriv[,id]))
    mean.subj.second.deriv[,id]<-apply(subj.second.deriv[,,id],2,mean)

  }

  est.first.deriv<-apply(mean.subj.first.deriv,1,mean)
  est.second.deriv<-apply(mean.subj.second.deriv,1,mean)

  ## array list to store predicted tms, true tms, and visits
  logit.true.first<-true.first.deriv
  logit.est.first<-est.first.deriv

  ## array list to store predicted tms, true tms, and visits
  logit.true.second<-true.second.deriv
  logit.est.second<-est.second.deriv




  ####################################
  # Plot of Second Derivatives of Omega
  ####################################

  postscript(paste(file,"second_derivative.eps",sep=""))
  #pdf(file="arctan_true_second.pdf")
  par(mar=c(6.1,5.1,2.5,1.1))

  ymin<-min(logit.est.second)-0.1
  ymax<-max(logit.est.second)+2.8
  #average of trajectories of all subjects
  plot(mean.true.xx, logit.true.second, ylim=c(ymin, ymax), xlim=c(xmin, xmax),
       xlab="x",  ylab=expression("paraNLME" (partialdiff^{2}~omega/ partialdiff~x^2)), col="black", lty=1, type="l",
       main="Average Second Derivative of Trajectories", cex.lab=1.3, cex.axis=1.0,
       lwd=2,  font=1.3)
  lines(mean.true.xx, logit.est.second, col="red", lty=2, lwd=2)
  legend( xmin, ymax,c("True Trajectory", "Estimated Trajectory"), col=c("black", "red"),
          lty=c(1,2),bty="n",cex=1.3,lwd=rep(2,2))
  mtext('(f)', outer=F,side=1,line=4.5, cex=1.3)

  dev.off()



  return(list(fixed.est=fixed.est,
              #scale.para=scale.para,
              glob.logT.est=glob.logT.est,   glob.logT.cp=glob.logT.cp))
}
