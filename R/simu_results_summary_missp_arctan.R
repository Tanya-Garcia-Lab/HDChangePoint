#' Summary results of the parametric NLME, when the true data are generated by the logistic model, but the parametric NLME assumes the incorrect arctangent model.
#'
#' @param nsim number of simulation runs.
#' @param n number of sample size.
#' @param res a nsim-length of list for simulation results.
#' @param beta a (p-1)-length of true coefficient vector corresponding to subject specific covariates.
#' @param beta0 true intercept of the log-normal model for the inflection point.
#' @param num.grid number of data points at which predictors are required for each individual longitudinal trajectory.
#' @param file a character string of file name for a creating plot in .eps file extention.
#'
#' @return A list of the summarized simulation results including
#'
#'        \item{res.table}{a data frame of the absolute biases, estimated standard deviations, average of the estimated standard errors and 95\% coverage probabilities for the fixed effects (\code{beta0}, \code{beta}).}
#'        \item{avr.est.Z}{a data frame of the average performance of inflection points for all subjects including the absolute biases, the empirical standard errors, bootstrap standard deviations and 95\% boostrap confidence intervals.}
#'
#' @export
#'
#' @examples
#'
#' library(HDChangePoint)
#'
#'
#' ## Specify parameters to generate true data
#' n=80;
#' model="logist";
#' p=2;
#' bb0=0.5;
#' bb=0.1;
#' x.sd=0.3;
#' v1=5;
#' v2=7;
#' dist="normal";
#' eps.sd=0.05;
#' u.sd=0.05;
#'
#' ## generate data with seed number
#'
#' set.seed(1)
#' outdat<-mydata(n=n, model=model, p=p, bb0=bb0, bb=bb, x.sd=x.sd, v1=v1, v2=v2, dist=dist, eps.sd=eps.sd, u.sd=u.sd)
#'
#'
#'
#'
#' ## Specify parameters for the parametric NLME procedure
#' n=80;
#' model="logist";
#' num.boot=1000;
#' true.theta1=6;
#' true.theta3=1;
#' num.grid=45;
#' eps.sd=0.05;
#' dist="normal";
#' para1=1;
#' para2=3.5;
#' para3=0;
#' para4=3;
#' para5=1;
#'
#'
#' ## Do parametric NLME estimation
#' results<-main.arctan.missp.nlme(n=n, model=model,  dat=outdat, num.boot=num.boot, num.grid=num.grid,
#'                                 true.theta1=true.theta1, true.theta3=true.theta3,  para1=para1,
#'                                 para2=para2, para3=para3, para4=para4, para5=para5,  eps.sd=eps.sd, dist=dist)
#'
#'
#'
#' ## Specify parameters to obtain the summary results
#'
#' nsim=100;
#' n=80;
#' num.grid=45;
#' beta=0.1;
#' beta0=0.5;
#' file="nlme_arctan_"
#'
#' ## summary results
#' simus.missp.arctan.out<-missp.arctan.results(nsim=nsim, n=n, res=results, num.grid=num.grid,  beta=beta, beta0=beta0, file=file)
#'
#'
#'
missp.arctan.results<-function(nsim=100, n=80, res=results, beta=0.1, beta0=0.5, num.grid=45, file="nlme_arctan_missp_"){

  #true.eps=0.05, true.u=0.05,
  #############################################
  ### Fixed effects                       #####
  ###    #theta1                          #####
  ###    #theta2 =beta*W_cov+ranom.effect #####
  #############################################

  ############
  ## estimates
  ############

  estimated.beta<-do.call("rbind",lapply(res,function(x) x$est.beta))
  estimated.beta0<-do.call("rbind",lapply(res,function(x) x$est.beta0))


  ## average of fixed effects
  mean.est.fixed.eff<-apply(cbind(estimated.beta, estimated.beta0),2, mean) #estimated.gam1, estimated.gam3,estimated.gam4,

  ## standard deviation of fixed effects
  sd.est.fixed.eff<-apply(cbind( estimated.beta, estimated.beta0),2, sd) #estimated.gam1, estimated.gam3,  estimated.gam4,

  ##
  true.fixed.eff<-c(beta, beta0) #gam1,gam3, gam4,


  ####################################
  ### bias of fixed estimates
  ####################################
  abs.bias.fixed.eff<-abs(mean.est.fixed.eff-true.fixed.eff)


  #############################################
  ## standard errors of fixed effects
  #############################################

  estimated.str.beta0<-do.call("rbind",lapply(res,function(x) x$est.str.beta0))
  estimated.str.beta<-do.call("rbind",lapply(res,function(x) x$est.str.beta))

  est.avr.str.beta0<-mean(estimated.str.beta0)
  est.avr.str.beta<-mean(estimated.str.beta)


  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta0))
  estimated.uppercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta0))


  ind1b0<- do.call("rbind",lapply(estimated.uppercp.beta0,function(x) 1*(x-(beta0)>0)))
  ind2b0<- do.call("rbind",lapply(estimated.lowercp.beta0,function(x) 1*(x-(beta0)<0)))
  indb0<-ind1b0*ind2b0

  cpb0<-mean(indb0)



  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta))
  estimated.uppercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta))

  ind1b<- do.call("rbind",lapply(estimated.uppercp.beta,function(x) 1*(x-(beta)>0)))
  ind2b<- do.call("rbind",lapply(estimated.lowercp.beta,function(x) 1*(x-(beta)<0)))
  indb<-ind1b*ind2b

  cpb<-mean(indb)



  ######################
  ### summarization ####
  ######################

  ## beta0
  #"est": mean.est.fixed.eff["gam2.(Intercept)"],
  estimates.beta0<-data.frame( abs.bias.fixed.eff["gam2.(Intercept)"], sd.est.fixed.eff["gam2.(Intercept)"],  est.avr.str.beta0,  cpb0)
  colnames(estimates.beta0)<-c( "BIAS", "ESD", "ASE", "CP")


  ## beta
  #"est": mean.est.fixed.eff["gam2.W.cov"],
  estimates.beta<-data.frame(  abs.bias.fixed.eff["gam2.W.cov"], sd.est.fixed.eff["gam2.W.cov"],  est.avr.str.beta,  cpb)
  colnames(estimates.beta)<-c( "BIAS", "ESD", "ASE", "CP")

  fixed.est<-rbind(estimates.beta0, estimates.beta)
  rownames(fixed.est)<-c("beta0", "beta") #"gam1", "gam3","gam4",
  fixed.est<-round(fixed.est, 3)


  #############################################
  ### Random effect where                   ###
  ###    #theta2 =beta*W_cov+ranom.effect   ###
  #############################################

  ## random effect for Each ID (columwise) based on 100 simulation
  estimated.random.eff<-do.call("rbind",lapply(res,function(x) x$est.rand.ef))
  avr.est.random.eff<-apply(estimated.random.eff,2, mean)


  #######################################################
  ## Inflection Point                               #####
  ## est.logT is the same as fixed effect theta2    #####
  ## est.logT=\hat(beta)*W_cov+\hat(ranom.effect)   #####
  #######################################################

  ###############
  # True logT  ##
  ###############

  TRUE.logT<-do.call("rbind",lapply(res,function(x) x$true.logT))
  tr.logT<-apply(TRUE.logT,2, mean)


  #############
  # Estimates #
  #############

  estimated.logT<-do.call("rbind",lapply(res,function(x) x$est.logT))
  ind.abs.bias<-abs(estimated.logT-TRUE.logT) ## individual biases for each subject
  avr.ind.abs.bias<-apply(ind.abs.bias, 1, mean) ## average ind.abs.bias across subjects

  ##############
  ## bias logT #
  ##############
  avr.sim.ind.abs.bias<-mean(avr.ind.abs.bias)

  ##############
  ## sd logT #
  ##############
  #avr.est.logT<-apply(estimated.logT,2, mean)
  sd.est.logT<-apply(estimated.logT,2, sd) # sd of logT over simulation runs
  avr.sd.est.logT<-mean(sd.est.logT)       # avr of sd of logT across subjects

  #bias.logT<-abs(avr.est.logT-tr.logT)   ## mean(bias.logT)

  ## bootstrap str
  #boot.est.logT=boot.est.logT,  ind.sd=ind.sd, cp.boot=cp.boot
  boot.ind.sd<-do.call("rbind",lapply(res,function(x) x$ind.sd))
  avr.boot.ind.sd<-apply(boot.ind.sd,2, mean) # average of bootstrap sd over simulation runs
  avr.boot.str<-mean(avr.boot.ind.sd) # average of bootstrap sd across subjects


  # sd(results[[1]]$boot.est.logT[1,])
  boot.est.cp<-do.call("rbind",lapply(res,function(x) x$cp.boot))
  boot.ind.cp<-array(0, dim=c(n, 2, nsim), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))
                                                         ,paste("sim",1:nsim,sep="")))

  for(s in 1:nsim){
    # s<-1
    boot.ind.cp[,, s]<-boot.est.cp[(1+(s-1)*80):(s*80),]
  }

  avr.boot.ind.cp<-array(0, dim=c(n, 2), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))))

  for (id in 1:n){
    avr.boot.ind.cp[id,]<-apply(boot.ind.cp[id,,1:nsim],1,mean)
  }



  ###################################
  ## average of inflection points ###
  ###################################
  avr.est.logT<-apply(estimated.logT, 2, mean)
  glob.logT<-mean(avr.est.logT)

  ## global bootstrap 95% coverage probability
  ind.logT.cp<-cbind(avr.est.logT, avr.boot.ind.cp)
  glob.logT.cp<-apply(ind.logT.cp, 2, mean)

  #################################
  ### global logT summarization ###
  #################################

  glob.logT.est<-cbind(avr.sim.ind.abs.bias,  avr.sd.est.logT, avr.boot.str, rbind(glob.logT.cp[2:3]))
  colnames(glob.logT.est)<-c("Bias", "ESD", "Boot.sd", "Boot.95%.cp.lower", "Boot.95%.cp.upper")
  rownames(glob.logT.est)<-c("est")
  glob.logT.est<-round(glob.logT.est, 3)


  ######################################
  ###### plot for estimated omega ######
  ######################################
  newl<-ceiling(num.grid/2)


  true.tms<-array(0, dim=c(nsim, newl, n),
                  dimnames = list(paste("sim",1:nsim,sep=""),paste("visit",1:newl,sep=""), paste("id",1:n,sep="")
                  ))
  subj.logS<-true.tms
  est.tms<-true.tms

  ind.avr.true.tms<-array(0, dim=c(newl, n),
                          dimnames = list(paste("visit",1:newl,sep=""), paste("id",1:n,sep="")
                          ))

  ind.avr.true.xx<-ind.avr.true.tms
  ind.avr.est.tms<-ind.avr.true.tms

  for (id in 1:n){
    for (sim in 1:nsim){

      true.tms[sim,,id]<-res[[sim]]$new.pred.data[, "ture.pseudo.tms", id]
      est.tms[sim,,id]<-res[[sim]]$new.pred.data[, "est.pseudo.tms", id]
      subj.logS[sim,,id]<-res[[sim]]$new.pred.data[, "pseudo.logS", id]
    }
    ind.avr.true.tms[, id]<- apply(true.tms[,, id], 2, mean)
    ind.avr.est.tms[, id]<- apply(est.tms[,, id], 2, mean)
    ind.avr.true.xx[, id]<- apply(subj.logS[,, id], 2, mean)
  }


  mean.true.tms<-apply(ind.avr.true.tms,1,mean)
  mean.est.tms<-apply(ind.avr.est.tms,1,mean)
  mean.true.xx<-apply(ind.avr.true.xx,1,mean)




  ################################################
  # Plot of Average of Longitudinal trajectories #
  ################################################

  postscript(paste(file,"average_longitudinal_trajectory.eps",sep=""))
  #pdf(file="missp_arctan_true.pdf")
  par(mar=c(6.1,5.1,2.5,1.1))

  ## Create a blank plot

  #average of trajectories of all subjects

  ymin<-min(mean.true.tms)-0.1
  ymax<-max(mean.true.tms)+0.5
  xmin<-min(mean.true.xx)-0.3
  xmax<-max(mean.true.xx)+0.3

  plot( mean.true.xx,      mean.true.tms, ylim=c(ymin,  ymax), xlim=c(xmin, xmax), xlab="x", ylab=expression("paraNLME"(omega(x))),
        cex.lab=1.3, cex.axis=1.0,
        main="Average of Individual Trajectories",  font=1.2,
        col="black", lty=1, lwd=2, type="l") # sub='(a)', cex.sub=1.3,

  lines( mean.true.xx,  mean.est.tms, col="blue", lty=3, lwd=2)

  segments( glob.logT, 0,  glob.logT,median(mean.est.tms)+0.5,  col="orange", lty=4, lwd=2)

  legend(xmin, ymax,c("True Trajectory", "Estimated Trajectory"), col=c("black", "blue"),
         lty=c(1,3),bty="n",cex=1.3,lwd=rep(2,2))
  mtext('(a)', outer=F,side=1,line=4.5, cex=1.3)

  dev.off()



  ###########################################
  ## First and Second Derivative Estimation #
  ###########################################


  ### True First Derivative : all simulations are the same at true values
  true.first.deriv<-apply(res[[1]]$true.first.deriv,1,mean)
  true.second.deriv<-apply(res[[1]]$true.second.deriv,1,mean)


  ## predicted values for omega at the population and subject levels

  subj.first.deriv<-array(0, dim=c(nsim, newl,n),
                          dimnames = list(paste("nsim",1:nsim,sep=""),paste("visit",1:newl,sep="")
                                          ,paste("ID",1:n,sep="")))

  subj.second.deriv<-subj.first.deriv
  mean.subj.first.deriv<-array(0, dim=c(newl,n),
                               dimnames = list(paste("visit",1:newl,sep="")
                                               ,paste("ID",1:n,sep="")))

  mean.subj.second.deriv<-mean.subj.first.deriv

  #res[[1]]$est.first.deriv
  for (id in 1:n){

    subj.first.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.first.deriv[,id]))
    mean.subj.first.deriv[,id]<-apply(subj.first.deriv[,,id],2,mean)

    subj.second.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.second.deriv[,id]))
    mean.subj.second.deriv[,id]<-apply(subj.second.deriv[,,id],2,mean)

  }

  est.first.deriv<-apply(mean.subj.first.deriv,1,mean)
  est.second.deriv<-apply(mean.subj.second.deriv,1,mean)

  ## array list to store predicted tms, true tms, and visits
  logit.true.first<-true.first.deriv
  logit.est.first<-est.first.deriv

  ## array list to store predicted tms, true tms, and visits
  logit.true.second<-true.second.deriv
  logit.est.second<-est.second.deriv



  ####################################
  # Plot of Second Derivatives of Omega
  ####################################

  postscript(paste(file,"second_derivative.eps",sep=""))
  #pdf(file="missp_arctan_second.pdf")
  par(mar=c(6.1,5.1,2.5,1.1))

  ymin<-min(logit.est.second)-0.1
  ymax<-max(logit.est.second)+1.3
  #average of trajectories of all subjects
  plot(mean.true.xx, logit.true.second,ylim=c(ymin, ymax), xlim=c(xmin, xmax),
       xlab="x", ylab=expression("paraNLME" (partialdiff^{2}~omega/ partialdiff~x^2)), col="black", lty=1, type="l",
       main="Average Second Derivative of Trajectories", cex.lab=1.3, cex.axis=1.0,
       lwd=2,  font=1.3)
  lines(mean.true.xx, logit.est.second, col="blue", lty=3, lwd=2)
  mtext('(b)', outer=F,side=1,line=4.5, cex=1.3)

  dev.off()




  return(list( fixed.est=fixed.est,
               glob.logT.est=glob.logT.est


  ))

}
