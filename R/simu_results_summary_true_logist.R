#' Summary results of the parametric NLME, when the true data are generated by the logistic model and the parametric NLME assumes the correct logistic  model.
#'
#' @param nsim number of simulation runs.
#' @param n number of sample size.
#' @param res a nsim-length of list for simulation results.
#' @param theta1 a true scale parameter, which determines steepness of the logistic model.
#' @param theta3 a true parameter, which determines the maximum (asymptote) of logstic model.
#' @param beta  a (p-1)-length of true coefficient vector corresponding to subject specific covariates.
#' @param beta0 true intercept of the log-normal model for the inflection point.
#' @param num.grid number of data points at which predictors are required for each individual longitudinal trajectory.
#' @param file a character string of file name for a creating plot in .eps file extention.
#'
#' @return A list of the summarized simulation results including
#'
#'        \item{res.table}{a data frame of the absolute biases, estimated standard deviations, average of the estimated standard errors and 95\% coverage probabilities for the fixed effects (\code{beta0}, \code{beta}).}
#'        \item{avr.est.Z}{a data frame of the average performance of inflection points for all subjects including the absolute biases, the empirical standard errors, bootstrap standard deviations and 95\% boostrap confidence intervals.}
#'
#' @export
#'
#' @examples
#'
#'
#' library(HDChangePoint)
#'
#'
#' ## Specify parameters to generate true data
#' n=80;
#' model="logist";
#' p=2;
#' bb0=0.5;
#' bb=0.1;
#' x.sd=0.3;
#' v1=5;
#' v2=7;
#' dist="normal";
#' eps.sd=0.05;
#' u.sd=0.05;
#'
#' ## generate data with seed number
#' set.seed(1)
#' outdat<-mydata(n=n, model=model, p=p, bb0=bb0, bb=bb, x.sd=x.sd, v1=v1, v2=v2, dist=dist, eps.sd=eps.sd, u.sd=u.sd)
#'
#'
#'
#' ## Specify parameters for the parametric NLME procedure
#' n=80;
#' model="logist";
#' num.boot=1000;
#' true.theta1=6;
#' true.theta3=1;
#' num.grid=45;
#' eps.sd=0.05;
#' dist="normal";
#' para1=4.3;
#' para2=4.1;
#' para3=0;
#' para4=1;
#'
#' ## Do parametric NLME estimation
#' results<-main.logist.nlme(n=n, model=model, dat=outdat, num.boot=num.boot,
#'                           true.theta1=true.theta1, true.theta3=true.theta3, num.grid=num.grid,
#'                           eps.sd=eps.sd, dist=dist, para1=para1, para2=para2, para3=para3, para4=para4)
#'
#'
#'
#'
#' ## Specify parameters to obtain the summary results
#'
#' nsim=100;
#' n=80;
#' theta1=6;
#' theta3=1;
#' beta0=0.5;
#' beta=0.1;
#' num.grid=45;
#' file="nlme_logist";
#'
#' ## summary results
#' simus.logist.out<-logit.results(nsim=nsim, n=n, res=results, theta1=theta1, theta3=theta3, beta=beta, beta0=beta0,
#'                                 num.grid=num.grid, file=file)
#'
#'
#'
logit.results<-function(nsim=100, n=80, res=results, theta1=6, theta3=1, beta=0.1, beta0=0.5, num.grid=45, file="nlme_logist"){


  #############################################
  ### Fixed effects                       #####
  ###    #theta1                          #####
  ###    #theta2 =beta*W_cov+ranom.effect #####
  #############################################

  #######################
  # TRUE Fixed Effects ##
  #######################

  true.fixed.eff<-c(theta1,theta3, beta, beta0)



  ##############
  ## estimates #
  ##############

  ## main fixed effects
  estimated.theta1<-do.call("rbind",lapply(res,function(x) x$est.theta1))
  estimated.theta3<-do.call("rbind",lapply(res,function(x) x$est.theta3))

  ## baseline effects
  estimated.beta<-do.call("rbind",lapply(res,function(x) x$est.beta))
  estimated.beta0<-do.call("rbind",lapply(res,function(x) x$est.beta0))


  ## average of fixed effects
  mean.est.fixed.eff<-apply(cbind(estimated.theta1, estimated.theta3,  estimated.beta, estimated.beta0),2, mean)

  ## standard deviation of fixed effects
  sd.est.fixed.eff<-apply(cbind(estimated.theta1, estimated.theta3,  estimated.beta, estimated.beta0),2, sd)



  ####################################
  ### bias of fixed estimates
  ####################################
  abs.bias.fixed.eff<-abs(mean.est.fixed.eff-true.fixed.eff)


  #############################################
  ## standard errors of fixed effects
  #############################################
  estimated.str.theta1<-do.call("rbind",lapply(res,function(x) x$est.str.theta1))
  estimated.str.theta3<-do.call("rbind",lapply(res,function(x) x$est.str.theta3))

  estimated.str.beta0<-do.call("rbind",lapply(res,function(x) x$est.str.beta0))
  estimated.str.beta<-do.call("rbind",lapply(res,function(x) x$est.str.beta))


  est.avr.str.theta1<-mean(estimated.str.theta1)
  est.avr.str.theta3<-mean(estimated.str.theta3)
  est.avr.str.beta0<-mean(estimated.str.beta0)
  est.avr.str.beta<-mean(estimated.str.beta)


  ########################################
  ## coverage probabilities for theta1
  ########################################
  estimated.lowercp.theta1<-do.call("rbind",lapply(res,function(x) x$cp.lower.theta1))
  estimated.uppercp.theta1<-do.call("rbind",lapply(res,function(x) x$cp.upper.theta1))
  #apply(cbind(estimated.lowercp.theta1,estimated.uppercp.theta1),2,mean)
  #UBtheta1<-estimated.theta1+1.96*estimated.str.theta1
  #LBtheta1<-estimated.theta1-1.96*estimated.str.theta1

  ind1theta1<- do.call("rbind",lapply(estimated.uppercp.theta1,function(x) 1*(x-(theta1)>0)))
  ind2theta1<- do.call("rbind",lapply(estimated.lowercp.theta1,function(x) 1*(x-(theta1)<0)))
  indtheta1<-ind1theta1*ind2theta1

  cptheta1<-mean(indtheta1)

  ########################################
  ## coverage probabilities for theta3 ###
  ########################################
  estimated.lowercp.theta3<-do.call("rbind",lapply(res,function(x) x$cp.lower.theta3))
  estimated.uppercp.theta3<-do.call("rbind",lapply(res,function(x) x$cp.upper.theta3))

  #UBtheta3<-estimated.theta3+1.96*estimated.str.theta3
  #LBtheta3<-estimated.theta3-1.96*estimated.str.theta3


  ind1theta3<- do.call("rbind",lapply(estimated.uppercp.theta3,function(x) 1*(x-(theta3)>0)))
  ind2theta3<- do.call("rbind",lapply(estimated.lowercp.theta3,function(x) 1*(x-(theta3)<0)))
  indtheta3<-ind1theta3*ind2theta3

  cptheta3<-mean(indtheta3)

  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta0))
  estimated.uppercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta0))

  #UBbeta0<-estimated.beta0+1.96*estimated.str.beta0
  #LBbeta0<-estimated.beta0-1.96*estimated.str.beta0


  ind1b0<- do.call("rbind",lapply(estimated.uppercp.beta0,function(x) 1*(x-(beta0)>0)))
  ind2b0<- do.call("rbind",lapply(estimated.lowercp.beta0,function(x) 1*(x-(beta0)<0)))
  indb0<-ind1b0*ind2b0

  cpb0<-mean(indb0)


  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta))
  estimated.uppercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta))

  #UBbeta<-estimated.beta+1.96*estimated.str.beta
  #LBbeta<-estimated.beta-1.96*estimated.str.beta


  ind1b<- do.call("rbind",lapply(estimated.uppercp.beta,function(x) 1*(x-(beta)>0)))
  ind2b<- do.call("rbind",lapply(estimated.lowercp.beta,function(x) 1*(x-(beta)<0)))
  indb<-ind1b*ind2b

  cpb<-mean(indb)

  ######################
  ### summarization ####
  ######################

  ## theta1
  estimates.theta1<-data.frame( abs.bias.fixed.eff["theta1"], sd.est.fixed.eff["theta1"],est.avr.str.theta1, cptheta1)
  colnames(estimates.theta1)<-c("Bias", "ESD", "ASE", "CP")

  ## theta3
  estimates.theta3<-data.frame( abs.bias.fixed.eff["theta3"], sd.est.fixed.eff["theta3"],est.avr.str.theta3, cptheta3)
  colnames(estimates.theta3)<-c("Bias", "ESD", "ASE", "CP")

  ## beta0
  estimates.beta0<-data.frame( abs.bias.fixed.eff["theta2.(Intercept)"], sd.est.fixed.eff["theta2.(Intercept)"],  est.avr.str.beta0,  cpb0)
  colnames(estimates.beta0)<-c("Bias", "ESD", "ASE", "CP")


  ## beta
  estimates.beta<-data.frame( abs.bias.fixed.eff["theta2.W.cov"], sd.est.fixed.eff["theta2.W.cov"],  est.avr.str.beta,  cpb)
  colnames(estimates.beta)<-c("Bias", "ESD", "ASE", "CP")

  #estimates.theta1,estimates.theta3,"theta1", "theta3",
  fixed.est<-rbind(estimates.beta0, estimates.beta)
  rownames(fixed.est)<-c("beta0", "beta")

  fixed.est<-round(fixed.est, 3)


  #############################################
  ### Random effect where                   ###
  ###    #theta2 =beta*W_cov+ranom.effect   ###
  #############################################

  ## random effect for Each ID (columwise) based on 100 simulation
  estimated.random.eff<-do.call("rbind",lapply(res,function(x) x$est.rand.ef))
  avr.est.random.eff<-apply(estimated.random.eff,2, mean)


  #######################################################
  ## Inflection Point                               #####
  ## est.logT is the same as fixed effect theta2    #####
  ## est.logT=\hat(beta)*W_cov+\hat(ranom.effect)   #####
  #######################################################

  ###############
  # True logT  ##
  ###############

  TRUE.logT<-do.call("rbind",lapply(res,function(x) x$true.logT))
  tr.logT<-apply(TRUE.logT,2, mean)


  #############
  # Estimates #
  #############

  estimated.logT<-do.call("rbind",lapply(res,function(x) x$est.logT))
  ind.abs.bias<-abs(estimated.logT-TRUE.logT) ## individual biases for each subject
  avr.ind.abs.bias<-apply(ind.abs.bias, 1, mean) ## average ind.abs.bias across subjects

  ##############
  ## bias logT #
  ##############
  avr.sim.ind.abs.bias<-mean(avr.ind.abs.bias)

  ##############
  ## sd logT #
  ##############
  #avr.est.logT<-apply(estimated.logT,2, mean)
  sd.est.logT<-apply(estimated.logT,2, sd) # sd of logT over simulation runs
  avr.sd.est.logT<-mean(sd.est.logT)       # avr of sd of logT across subjects
  #bias.logT<-abs(avr.est.logT-tr.logT)   ## mean(bias.logT)

  ## bootstrap standard deviation
  boot.ind.sd<-do.call("rbind",lapply(res,function(x) x$ind.sd))
  avr.boot.ind.sd<-apply(boot.ind.sd,2, mean) # average of bootstrap sd over simulation runs
  avr.boot.str<-mean(avr.boot.ind.sd) # average of bootstrap sd across subjects


  # boostrap 95% confidence interval
  boot.est.cp<-do.call("rbind",lapply(res,function(x) x$cp.boot))
  boot.ind.cp<-array(0, dim=c(n, 2, nsim), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))
                                                         ,paste("sim",1:nsim,sep="")))

  for(s in 1:nsim){
    # s<-1
    boot.ind.cp[,, s]<-boot.est.cp[(1+(s-1)*80):(s*80),]
  }

  avr.boot.ind.cp<-array(0, dim=c(n, 2), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))))

  for (id in 1:n){
    avr.boot.ind.cp[id,]<-apply(boot.ind.cp[id,,1:nsim],1,mean)
  }



  ###################################
  ## average of inflection points ###
  ###################################
  avr.est.logT<-apply(estimated.logT, 2, mean)
  glob.logT<-mean(avr.est.logT)

  ## global bootstrap 95% coverage probability
  ind.logT.cp<-cbind(avr.est.logT, avr.boot.ind.cp)
  glob.logT.cp<-apply(ind.logT.cp, 2, mean)

  #################################
  ### global logT summarization ###
  #################################

  glob.logT.est<-cbind(avr.sim.ind.abs.bias,  avr.sd.est.logT, avr.boot.str, rbind(glob.logT.cp[2:3]))
  colnames(glob.logT.est)<-c("Bias", "ESD", "Boot.sd", "Boot.95%.cp.lower", "Boot.95%.cp.upper")
  rownames(glob.logT.est)<-c("est")
  glob.logT.est<-round(glob.logT.est, 3)


  ######################################
  ###### plot for estimated omega ######
  ######################################

  newl<-ceiling(num.grid /2)



  true.tms<-array(0, dim=c(nsim, newl, n),
                  dimnames = list(paste("sim",1:nsim,sep=""),paste("visit",1:newl,sep=""), paste("id",1:id,sep="")
                  ))
  subj.logS<-true.tms
  est.tms<-true.tms

  ind.avr.true.tms<-array(0, dim=c(newl, n),
                          dimnames = list(paste("visit",1:newl,sep=""), paste("id",1:id,sep="")
                          ))

  ind.avr.true.xx<-ind.avr.true.tms
  ind.avr.est.tms<-ind.avr.true.tms

  for (id in 1:n){
    for (sim in 1:nsim){

      true.tms[sim,,id]<-res[[sim]]$new.pred.data[, "ture.pseudo.tms", id]
      est.tms[sim,,id]<-res[[sim]]$new.pred.data[, "est.pseudo.tms", id]
      subj.logS[sim,,id]<-res[[sim]]$new.pred.data[, "pseudo.logS", id]
    }
    ind.avr.true.tms[, id]<- apply(true.tms[,, id], 2, mean)
    ind.avr.est.tms[, id]<- apply(est.tms[,, id], 2, mean)
    ind.avr.true.xx[, id]<- apply(subj.logS[,, id], 2, mean)
  }


  mean.true.tms<-apply(ind.avr.true.tms,1,mean)
  mean.est.tms<-apply(ind.avr.est.tms,1,mean)
  mean.true.xx<-apply(ind.avr.true.xx,1,mean)




  ################################################
  # Plot of Average of Longitudinal trajectories #
  ################################################

  postscript(paste(file,"average_longitudinal_trajectory.eps",sep=""))
  #pdf(file="avr_traj_logist_true.pdf")
  par(mar=c(6.1,5.1,2.5,1.1))

  ## Create a blank plot
  ymin<-min(mean.true.tms)-0.1
  ymax<-max(mean.true.tms)+0.5
  xmin<-min(mean.true.xx)-0.3
  xmax<-max(mean.true.xx)+0.3
  #average of trajectories of all subjects
  plot( mean.true.xx,      mean.true.tms, ylim=c(ymin,  ymax), xlim=c(xmin, xmax), xlab="x", ylab=expression("paraNLME"(omega(x))),
        cex.lab=1.3, cex.axis=1.0,
        main="Average of Individual Trajectories",  font=1.2,
        col="black", lty=1, lwd=2, type="l") # sub='(a)', cex.sub=1.3,

  lines( mean.true.xx,  mean.est.tms, col="red", lty=2, lwd=2)

  segments( glob.logT, 0,  glob.logT,median(mean.est.tms)+0.5,  col="blue", lty=3, lwd=2)

  legend( xmin, ymax,c("True Trajectory", "Estimated Trajectory"), col=c("black", "red"),
          lty=c(1,2),bty="n",cex=1.3,lwd=rep(2,2))
  mtext('(a)', outer=F,side=1,line=4.5, cex=1.3)

  dev.off()




  ###########################################
  ## First and Second Derivative Estimation #
  ###########################################


  ### True First Derivative : all simulations are the same at true values
  true.first.deriv<-apply(res[[1]]$true.first.deriv,1,mean)
  true.second.deriv<-apply(res[[1]]$true.second.deriv,1,mean)


  ## predicted values for omega at the population and subject levels

  subj.first.deriv<-array(0, dim=c(nsim, newl,n),
                          dimnames = list(paste("nsim",1:nsim,sep=""),paste("visit",1:newl,sep="")
                                          ,paste("ID",1:n,sep="")))

  subj.second.deriv<-subj.first.deriv
  mean.subj.first.deriv<-array(0, dim=c(newl,n),
                               dimnames = list(paste("visit",1:newl,sep="")
                                               ,paste("ID",1:n,sep="")))

  mean.subj.second.deriv<-mean.subj.first.deriv


  for (id in 1:n){

    subj.first.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.first.deriv[,id]))
    mean.subj.first.deriv[,id]<-apply(subj.first.deriv[,,id],2,mean)

    subj.second.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.second.deriv[,id]))
    mean.subj.second.deriv[,id]<-apply(subj.second.deriv[,,id],2,mean)

  }

  est.first.deriv<-apply(mean.subj.first.deriv,1,mean)
  est.second.deriv<-apply(mean.subj.second.deriv,1,mean)

  ## array list to store predicted tms, true tms, and visits
  logit.true.first<-true.first.deriv
  logit.est.first<-est.first.deriv

  ## array list to store predicted tms, true tms, and visits
  logit.true.second<-true.second.deriv
  logit.est.second<-est.second.deriv



  ####################################
  # Plot of Second Derivatives of Omega
  ####################################

  postscript(paste(file,"second_derivative.eps",sep=""))
  #pdf(file="avr_traj_logist_second.pdf")
  par(mar=c(6.1,5.1,2.5,1.1))
  #average of trajectories of all subjects
  ymin<-min(logit.est.second)-0.1
  ymax<-max(logit.est.second)+1.3

  plot(mean.true.xx, logit.true.second, ylim=c(ymin, ymax), xlim=c(xmin, xmax),
       xlab="x", ylab=expression("paraNLME" (partialdiff^{2}~omega/ partialdiff~x^2)), col="black", lty=1, type="l",
       main="Average Second Derivative of Trajectories", cex.lab=1.3, cex.axis=1.0,
       lwd=2,  font=1.3)
  lines(mean.true.xx, logit.est.second, col="red", lty=2, lwd=2)
  legend( xmin, ymax,c("True Trajectory", "Estimated Trajectory"), col=c("black", "red"),
          lty=c(1,2),bty="n",cex=1.3,lwd=rep(2,2))
  mtext('(b)', outer=F,side=1,line=4.5, cex=1.3)


  dev.off()

  return(list(fixed.est=fixed.est,
              glob.logT.est=glob.logT.est

  ))

}


