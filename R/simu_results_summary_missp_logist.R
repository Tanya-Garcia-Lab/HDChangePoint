#' Summary results of the parametric NLME, when the true data are generated by the arctangent model, but the parametric NLME assumes the incorrect logistic model.
#'
#' @param nsim number of simulation runs.
#' @param n number of sample size.
#' @param res a nsim-length of list for simulation results.
#' @param beta a (p-1)-length of true coefficient vector corresponding to subject specific covariates.
#' @param beta0 true intercept of the log-normal model for the inflection point.
#' @param time.length number of data points at which predictors are required for each individual longitudinal trajectory. This time point for graphs to be plotted.
#' @param file a character string of file name for a creating plot in .eps file extention.
#'
#' @return A list of the summarized simulation results including
#'
#'        \item{res.table}{a data frame of the absolute biases, estimated standard deviations, average of the estimated standard errors and 95\% coverage probabilities for the fixed effects (\code{beta0}, \code{beta}).}
#'        \item{Rel.glob.logT.est}{a data frame of the relative average performance of inflection points for all subjects including the relative absolute biases, the relative empirical standard errors, the relative bootstrap standard deviations and 95\% boostrap confidence intervals.}
#'
#' @export
#'
#' @examples
#'
#' library(HDChangePoint)
#' data(missp_logist_visit1)
#'
#' ## Specify parameters to obtain the summary results
#'
#' nsim=100;
#' n=80;
#' time.length=20;
#' beta=0.1;
#' beta0=2;
#' file="nlme_arctan_"
#'
#' ## summary results
#' simus.missp.logist.out<-missp.logist.results(nsim=nsim, n=n, res=results, time.length=time.length ,  beta=beta, beta0=beta0,  file=file)
#'
#'

missp.logist.results<-function(nsim=100, n=80, res=results, time.length=20, beta=0.1, beta0=2, file="nlme_logisic"){


  #############################################
  ### Fixed effects                       #####
  ###    #theta1                          #####
  ###    #theta2 =beta*W_cov+ranom.effect #####
  #############################################

  #######################
  # TRUE Fixed Effects ##
  #######################

  true.fixed.eff<-c( beta, beta0)



  ##############
  ## estimates #
  ##############

  ## baseline effects
  estimated.beta<-do.call("rbind",lapply(res,function(x) x$est.beta))
  estimated.beta0<-do.call("rbind",lapply(res,function(x) x$est.beta0))


  ## average of fixed effects
  mean.est.fixed.eff<-apply(cbind( estimated.beta, estimated.beta0),2, mean)

  ## standard deviation of fixed effects
  sd.est.fixed.eff<-apply(cbind(  estimated.beta, estimated.beta0),2, sd)



  ####################################
  ### bias of fixed estimates
  ####################################
  abs.bias.fixed.eff<-abs(mean.est.fixed.eff-true.fixed.eff)


  #############################################
  ## standard errors of fixed effects
  #############################################

  estimated.str.beta0<-do.call("rbind",lapply(res,function(x) x$est.str.beta0))
  estimated.str.beta<-do.call("rbind",lapply(res,function(x) x$est.str.beta))



  est.avr.str.beta0<-mean(estimated.str.beta0)
  est.avr.str.beta<-mean(estimated.str.beta)


  ########################################
  ## coverage probabilities for theta1
  ########################################


  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta0))
  estimated.uppercp.beta0<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta0))


  ind1b0<- do.call("rbind",lapply(estimated.uppercp.beta0,function(x) 1*(x-(beta0)>0)))
  ind2b0<- do.call("rbind",lapply(estimated.lowercp.beta0,function(x) 1*(x-(beta0)<0)))
  indb0<-ind1b0*ind2b0

  cpb0<-mean(indb0)


  ########################################
  ## coverage probabilities for beta
  ########################################
  estimated.lowercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.lower.beta))
  estimated.uppercp.beta<-do.call("rbind",lapply(res,function(x) x$cp.upper.beta))

  ind1b<- do.call("rbind",lapply(estimated.uppercp.beta,function(x) 1*(x-(beta)>0)))
  ind2b<- do.call("rbind",lapply(estimated.lowercp.beta,function(x) 1*(x-(beta)<0)))
  indb<-ind1b*ind2b

  cpb<-mean(indb)

  ######################
  ### summarization ####
  ######################

  ## beta0
  estimates.beta0<-data.frame( abs.bias.fixed.eff["theta2.(Intercept)"], sd.est.fixed.eff["theta2.(Intercept)"],  est.avr.str.beta0,  cpb0)
  colnames(estimates.beta0)<-c( "abs.bias", "sd", "str", "cp")


  ## beta
  estimates.beta<-data.frame(  abs.bias.fixed.eff["theta2.W.cov"], sd.est.fixed.eff["theta2.W.cov"],  est.avr.str.beta,  cpb)
  colnames(estimates.beta)<-c( "abs.bias", "sd", "str", "cp")

  fixed.est<-rbind( estimates.beta0, estimates.beta) #estimates.theta1,estimates.theta3,
  rownames(fixed.est)<-c( "beta0", "beta") #"theta1", "theta3",

  fixed.est<-round(fixed.est,2)

  ######################################
  ## within individual scale parameter #
  ######################################
  estimated.sigma.eps<-do.call("rbind",lapply(res,function(x) x$sig.eps))
  mean.est.sigma.eps<-mean(estimated.sigma.eps)
  sd.est.sigma.eps<-sd(estimated.sigma.eps)


  #############################################
  ### Random effect where                   ###
  ###    #theta2 =beta*W_cov+ranom.effect   ###
  #############################################

  ## random effect for Each ID (columwise) based on 100 simulation
  estimated.random.eff<-do.call("rbind",lapply(res,function(x) x$est.rand.ef))
  avr.est.random.eff<-apply(estimated.random.eff,2, mean)


  #######################################################
  ## Inflection Point                               #####
  ## est.logT is the same as fixed effect theta2    #####
  ## est.logT=\hat(beta)*W_cov+\hat(ranom.effect)   #####
  #######################################################

  ###############
  # True logT  ##
  ###############

  TRUE.logT<-do.call("rbind",lapply(res,function(x) x$true.logT))
  tr.logT<-apply(TRUE.logT,2, mean)
  avr.tr.logT<-mean(tr.logT)

  #############
  # Estimates #
  #############

  estimated.logT<-do.call("rbind",lapply(res,function(x) x$est.logT))
  ind.abs.bias<-abs(estimated.logT-TRUE.logT) ## individual biases for each subject
  avr.ind.abs.bias<-apply(ind.abs.bias, 1, mean) ## average ind.abs.bias across subjects


  ##############
  ## bias logT #
  ##############
  avr.sim.ind.abs.bias<-mean(avr.ind.abs.bias)

  ##############
  ## sd logT #
  ##############
  #avr.est.logT<-apply(estimated.logT,2, mean)
  sd.est.logT<-apply(estimated.logT,2, sd) # sd of logT over simulation runs
  avr.sd.est.logT<-mean(sd.est.logT)       # avr of sd of logT across subjects


  ## bootstrap str
  #boot.est.logT=boot.est.logT,  ind.sd=ind.sd, cp.boot=cp.boot
  boot.ind.sd<-do.call("rbind",lapply(res,function(x) x$ind.sd))
  avr.boot.ind.sd<-apply(boot.ind.sd,2, mean) # average of bootstrap sd over simulation runs
  avr.boot.str<-mean(avr.boot.ind.sd) # average of bootstrap sd across subjects


  # sd(results[[1]]$boot.est.logT[1,])
  boot.est.cp<-do.call("rbind",lapply(res,function(x) x$cp.boot))
  boot.ind.cp<-array(0, dim=c(n, 2, nsim), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))
                                                         ,paste("sim",1:nsim,sep="")))

  for(s in 1:nsim){
    # s<-1
    boot.ind.cp[,, s]<-boot.est.cp[(1+(s-1)*80):(s*80),]
  }

  avr.boot.ind.cp<-array(0, dim=c(n, 2), dimnames=list(paste("id",1:n,sep=""),paste(c("95%lower", "95%upper"))))

  for (id in 1:n){
    avr.boot.ind.cp[id,]<-apply(boot.ind.cp[id,,1:nsim],1,mean)
  }



  ###################################
  ## average of inflection points ###
  ###################################
  avr.est.logT<-apply(estimated.logT, 2, mean)
  glob.logT<-mean(avr.est.logT)

  ## global bootstrap 95% coverage probability
  ind.logT.cp<-cbind(avr.est.logT, avr.boot.ind.cp)
  glob.logT.cp<-apply(ind.logT.cp, 2, mean)
  #################################
  ### global logT summarization ###
  #################################


  glob.logT.est<-cbind(avr.sim.ind.abs.bias,  avr.sd.est.logT, avr.boot.str)
  #colnames(glob.logT.est)<-c("Bias", "ESD", "ASE")
  #rownames(glob.logT.est)<-c("est")
  #glob.logT.est<-round(glob.logT.est, 3)

  Rel.glob.logT.est<-cbind(avr.sim.ind.abs.bias/avr.tr.logT,  avr.sd.est.logT/avr.tr.logT, avr.boot.str/avr.tr.logT, rbind(glob.logT.cp[2:3]))
  colnames(Rel.glob.logT.est)<-c("Rel.Bias", "Rel.ESD", "Rel.Boot.sd", "Boot.95%.cp.lower", "Boot.95%.cp.upper")
  rownames(Rel.glob.logT.est)<-c("est")
  Rel.glob.logT.est<-round(Rel.glob.logT.est, 2)


  ######################################
  ###### plot for estimated omega ######
  ######################################


  newl<-time.length



  true.tms<-array(0, dim=c(nsim, newl, n),
                  dimnames = list(paste("sim",1:nsim,sep=""),paste("visit",1:newl,sep=""), paste("id",1:id,sep="")
                  ))
  subj.logS<-true.tms
  est.tms<-true.tms

  ind.avr.true.tms<-array(0, dim=c(newl, n),
                          dimnames = list(paste("visit",1:newl,sep=""), paste("id",1:id,sep="")
                          ))

  ind.avr.true.xx<-ind.avr.true.tms
  ind.avr.est.tms<-ind.avr.true.tms

  for (id in 1:n){
    for (sim in 1:nsim){

      true.tms[sim,,id]<-res[[sim]]$new.pred.data[, "ture.pseudo.tms", id]
      est.tms[sim,,id]<-res[[sim]]$new.pred.data[, "est.pseudo.tms", id]
      subj.logS[sim,,id]<-res[[sim]]$new.pred.data[, "pseudo.logS", id]
    }
    ind.avr.true.tms[, id]<- apply(true.tms[,, id], 2, mean)
    ind.avr.est.tms[, id]<- apply(est.tms[,, id], 2, mean)
    ind.avr.true.xx[, id]<- apply(subj.logS[,, id], 2, mean)
  }


  mean.true.tms<-apply(ind.avr.true.tms,1,mean)
  mean.est.tms<-apply(ind.avr.est.tms,1,mean)
  mean.true.xx<-apply(ind.avr.true.xx,1,mean)




  ################################################
  # Plot of Average of Longitudinal trajectories #
  ################################################

  postscript(paste(file,"average_longitudinal_trajectory.eps",sep=""))
  par(mar=c(6.1,5.1,2.5,1.1))

  ## Create a blank plot
  ymax<-max(mean.true.tms)+0.5
  xmin<-min(mean.true.xx)-0.3
  xmax<-max(mean.true.xx)+0.3
  ymin<-min(mean.true.tms)-0.1

  #average of trajectories of all subjects

  plot( mean.true.xx, mean.true.tms, ylim=c(ymin,  ymax), xlim=c(xmin, xmax), xlab="x", ylab=expression("paraNLME"(omega(x))),
        cex.lab=1.3, cex.axis=1.0,
        main="Average of Individual Trajectories",  font=1.2,
        col="black", lty=1, lwd=2, type="l") # sub='(a)', cex.sub=1.3,

  lines( mean.true.xx,  mean.est.tms, col="blue", lty=3, lwd=2)

  segments(glob.logT, 0, glob.logT, median(mean.est.tms)+0.5,  col="orange", lty=4, lwd=2)

  legend(xmin, ymax,c("True Trajectory", "Estimated Trajectory"), col=c("black", "blue"),
         lty=c(1,3),bty="n",cex=1.3,lwd=rep(2,2))
  mtext('(e)', outer=F,side=1,line=4.5, cex=1.3)

  dev.off()



  ###########################################
  ## First and Second Derivative Estimation #
  ###########################################


  ### True First Derivative : all simulations are the same at true values
  true.first.deriv<-apply(res[[1]]$true.first.deriv,1,mean)
  true.second.deriv<-apply(res[[1]]$true.second.deriv,1,mean)


  ## predicted values for omega at the population and subject levels

  subj.first.deriv<-array(0, dim=c(nsim, newl,n),
                          dimnames = list(paste("nsim",1:nsim,sep=""),paste("visit",1:newl,sep="")
                                          ,paste("ID",1:n,sep="")))

  subj.second.deriv<-subj.first.deriv
  mean.subj.first.deriv<-array(0, dim=c(newl,n),
                               dimnames = list(paste("visit",1:newl,sep="")
                                               ,paste("ID",1:n,sep="")))

  mean.subj.second.deriv<-mean.subj.first.deriv


  for (id in 1:n){

    subj.first.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.first.deriv[,id]))
    mean.subj.first.deriv[,id]<-apply(subj.first.deriv[,,id],2,mean)

    subj.second.deriv[,,id]<-do.call("rbind",lapply(res,function(x) x$est.second.deriv[,id]))
    mean.subj.second.deriv[,id]<-apply(subj.second.deriv[,,id],2,mean)

  }

  est.first.deriv<-apply(mean.subj.first.deriv,1,mean)
  est.second.deriv<-apply(mean.subj.second.deriv,1,mean)

  ## array list to store predicted tms, true tms, and visits
  arctan.true.first<-true.first.deriv
  logit.est.first<-est.first.deriv

  ## array list to store predicted tms, true tms, and visits
  arctan.true.second<-true.second.deriv
  logit.est.second<-est.second.deriv


  ####################################
  # Plot of Second Derivatives of Omega
  ####################################

  postscript(paste(file,"second_derivative.eps",sep=""))
  #pdf(file="arctan_missp_logsit_sec.pdf")
  par(mar=c(6.1,5.1,2.5,1.1))

  ymin<-min(logit.true.second)-0.8
  ymax<-max(logit.true.second)+2.3
  #average of trajectories of all subjects
  plot(mean.true.xx, logit.true.second, ylim=c(ymin, ymax), xlim=c(xmin, xmax),
       xlab="x", ylab=expression("paraNLME" (partialdiff^{2}~omega/ partialdiff~x^2)), col="black", lty=1, type="l",
       main="Average Second Derivative of Trajectories", cex.lab=1.3, cex.axis=1.0,
       lwd=2,  font=1.3)
  lines(mean.true.xx, logit.est.second, col="blue", lty=3, lwd=2)
  mtext('(f)', outer=F,side=1,line=4.5, cex=1.3)

  dev.off()



  return(list(fixed.est=fixed.est,
              Rel.glob.logT.est=Rel.glob.logT.est
              #glob.logT.est=glob.logT.est
              ))

}
